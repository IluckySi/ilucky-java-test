nio是java New IO的简称, 在jdk1.4里提供的新api.
Sun官方标榜的特性如下:
1. 为所有的原始类型提供(Buffer)缓存支持.
2. 字符集编码解码解决方案.
3. 一个新的原始I/O抽象Channel.
4. 支持锁和内存映射文件的文件访问接口.
5. 提供多路(non-bloking)非阻塞式的高伸缩性网络I/O.
NIO真的象官方说的这么强大吗?首先看下面的这个实例:普通IO(带缓冲区的)读写文件和NIO读写文件的性能对比.
直接看代码:IoMainTest和NioMainTest.

通过代码我们可以看出针对简单的读写操作NIO并不占优势,基本上和普通IO(带缓冲区的)读写文件性能不相上下,
甚至还稍微低一些,那么NIO的优势在哪里呢?
下面通过一个实例来展示一下基于NIO的多路非阻塞网络服务器.
1. 创建服务器,直接看代码NioServer.
2. 创建客户端,直接看代码NioClientOne和NioClientTwo.

看完了基于NIO的多路非阻塞网络服务器,再回顾一下阻塞服务器. 
1.创建服务器,直接看代码IoServer.
2.创建客户端,直接看代码IoClientOne和IoClientTwo.
从上面的两个小例子中可以得知:
传统的java网络编程中都是在服务端创建一个ServerSocket,然后为每一个客户端单独创建一个线程处理请求,
由于对于CPU而言,线程的开销是很重要的,无限创建线程会让操作系统崩溃,因此,比较好的方法是在系统启动的时候创建一个动态的线程池,
例如Tomcat就是采用这种解决方案,然而,这种解决方案在高并发的情况下也不是很乐观,当线程池大小超过CPU瓶颈的时候,
速度就明显降低了.然而有了nio以后,服务端无需再创建多个线程,也无需创建线程池,仅仅只需要1个线程即可以处理全部客户端请求,
通过这一个线程nio服务器将每一个客户端连接请求注册到特定的Selector对象上,这就可以在单线程中利用Selector对象管理大量
并发的网络连接,更好的利用了系统资源.

nio通信过程:
当有读或写等任何注册的事件发生时,可以从Selector中获得相应的SelectionKey,从SelectionKey中可以找到发生的事件和该事件
所发生的具体的SelectableChannel,以获得客户端发送过来的数据.
由于在非阻塞网络I/O中采用了事件触发机制,处理程序可以得到系统的主动通知,从而可以实现底层网络I/O无阻塞,流畅地读写,
而不像在原来的阻塞模式下处理程序需要不断循环等待.使用NIO,可以编写出性能更好,更易扩展的并发型服务器程序.

nio的设计原理:
设计原理有点像设计模式中的观察者模式, 由Selector去轮流咨询各个SocketChannel通道是否有事件发生,如果有,则选择出所有的Key
集合,然后传递给处理程序.我们通过每个key就可以获取客户端的SocketChannel,从而进行通信.
如果Selector发现所有通道都没有事件发生, 则线程进入睡眠状态Sleep,即阻塞,等到客户端有事件发生时会自动唤醒选择器selector.

知识补充:
针对阻塞和非阻塞的区别有一很好的例子可以说明,摘抄如下:
一辆从A开往B的公共汽车上,中途会有很多人下车,但是司机并不知道这些人从哪里下车,针对这种情况有两种解决方案.
1. 司机在开车过程中定时询问每个乘客是否到达目的地,如果有人说到了,司机停车,乘客下车(阻塞模式).
2. 每个乘客(相当于套接字通道)告诉售票员(相当于Selector)自己的目的地(相当于注册事件),然后做自己的事情,听歌,睡觉等.
  司机(相当于CPU)只和售票员交互,到了某个目的地由售票员通知乘客下车(非阻塞模式).
很显然,在阻塞模式里面,每个线程需要不断的轮询,即询问司机是否到达目的地,从而不断的进行上下文切换(很耗费资源).
而在非阻塞模式里面,a每个乘客(线程)都在做自己的事情(休眠),只有真正外部环境准备好了后(即得到售票员通知)才被唤醒,这样的模式肯定不会阻塞.


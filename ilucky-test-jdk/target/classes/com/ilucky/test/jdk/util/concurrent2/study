队列和线程池

http://xtu-xiaoxin.iteye.com/blog/647580



	package com.ilucky.test.jdk.util.concurrent2;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * 线程的使用在java中占有极其重要的地位，在jdk1.4及其之前的jdk版本中，关于线程池的使用是极其简陋的。在jdk1.5之后这一情况有了很大的改观。
 * Jdk1.5之后加入了java.util.concurrent包，这个包中主要介绍java中线程以及线程池的使用。为我们在开发中处理线程的问题提供了非常大的帮助。
 * 
 * 为什么要用线程池:
 * 1. 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
 * 2. 可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，
 *     每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机。
 * 
 * Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。
 * 真正的线程池接口是ExecutorService。
 * 比较重要的几个类：
 * ExecutorService 真正的线程池接口。
 * ThreadPoolExecutor ExecutorService的默认实现。
 * ScheduledExecutorService 能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。
 * 
 * ScheduledThreadPoolExecutor 继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。
 * 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，
 * 因此在Executors类里面提供了一些静态工厂, 生成一些常用的线程池。
 * @author IluckySi
 */
public class ThreadPoolExecutorTest {

	public static void main(String[] args) {
		//testSingleThreadExecutor();
		//testFixedThreadPool();
		//testCachedThreadPool();
		testScheduledThreadPool();
	}

	/**
	 * 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。
	 * 如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
	 */
	private static void testSingleThreadExecutor(){
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        Thread t1 = new MyThread();
        Thread t2 = new MyThread();
        Thread t3 = new MyThread();
        executorService.execute(t1);
        executorService.execute(t2);
        executorService.execute(t3);
	}
	
	/**
	 * 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，
	 * 如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
	 */
	private static void testFixedThreadPool() {
		ExecutorService executorService = Executors.newFixedThreadPool(2);
        Thread t1 = new MyThread();
        Thread t2 = new MyThread();
        Thread t3 = new MyThread();
        executorService.execute(t1);
        executorService.execute(t2);
        executorService.execute(t3);
	}
	
	/**
	 * 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，
     * 那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。
     * 此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
	 */
	private static void testCachedThreadPool(){
		ExecutorService executorService = Executors.newCachedThreadPool();
        Thread t1 = new MyThread();
        Thread t2 = new MyThread();
        Thread t3 = new MyThread();
        executorService.execute(t1);
        executorService.execute(t2);
        executorService.execute(t3);
	}
	
	/**
	 * 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。
	 */
	private static void testScheduledThreadPool() {
		HeartBeatThread heartBeatThread = new HeartBeatThread();
		DiscoverThread discoverThread = new DiscoverThread();
		ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2);
		executorService.scheduleWithFixedDelay(heartBeatThread, 0, 5, TimeUnit.SECONDS);
		executorService.scheduleWithFixedDelay(discoverThread, 0, 10, TimeUnit.SECONDS);
		//executorService.shutdown();
	}
}

class HeartBeatThread implements Runnable {

	public void run() {
		System.out.println("heartBeat");
	}
}

class DiscoverThread implements Runnable {

	public void run() {
		System.out.println("discover");
	}
}

class MyThread extends Thread {
   
	@Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "正在执行");
        try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
    }
}
